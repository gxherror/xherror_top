---
title: "测试"
description: 学习 
date: 2022-11-06T06:27:44Z
image: 
math: 
license: 
hidden: false
comments: true
categories:
    - SE
tags:
---
## 概括

![691d121931e9e2d5211aea84e0b3db46.png](/images/691d121931e9e2d5211aea84e0b3db46.png)

成功的测试：发现错误

- 尽早测试
- 专人测试
- 正确数据集测试
- 不正确数据集测试
- 严格测试
- 保存测试

## 单元测试

在模块编写完成且无编译错误即可进行，通常白盒子测试

![image-20221104222527563](/images/image-20221104222527563.png)

![image-20221104222210398](/images/image-20221104222210398.png)

## 集成测试

- 自顶向下集成方法是从主控制模块开始，沿着程序的控制层次向下移动，逐渐把各个模块结合起来
  - 深度优先的结合方法/宽度优先的结合方法
  - 不需要测试驱动程序，能够在测试阶段的早期实现并验证系统的主要功能，而且能在早期发现上层模块的接口错误
  - 需要存根程序，可能遇到与此相联系的测试困难，低层关键模块中的错误发现较晚，而且用这种方法在早期不能充分展开人力
- 自底向上测试从“原子”模块(即在软件结构最低层的模块)开始组装和测试
- 回归测试，有新增模块进集成测试，重新执行已测试过的某些子集
- 冒烟测试：频繁进行评估

## 系统测试

## 确认测试

- Alpha测试由用户在开发者的场所进行，并且在开发者对用户的“指导”下进行测试
- Beta测试由软件的最终用户们在一个或多个客户场所进行。与Alpha测试不同，开发者通常不在Beta测试的现场

## 黑盒测试 

动态测试，又称**功能**测试，黑盒测试是在**程序接口**进行的测试，与白盒测试互补的测试方法，主要用于测试过程的后期

(1) 功能不正确或遗漏了功能；
(2) 界面错误；
(3) 数据结构错误或外部数据库访问错误；
(4) 性能错误；
(5) 初始化和终止错误。

- 等价类划分

- 边界值分析法
  - 两(三?)点分析法
    - 上点就是区间的端点值
    - 内点就是上点之间任意一点
    - 离点，要分具体情况，如果开区间的离点，就是开区间中上点内侧紧邻的点；如果是闭区间的离点，就是闭区间中上点外侧紧邻的点

- 错误推测法，推测哪里有错误
- 因果图，判定表

## 白盒测试 

动态测试，又称**结构**测试，测试者完全知道程序的结构和处理算法，在测试过程的**早期**阶段进行

### 逻辑覆盖

![img](/images/20210320173305545.png)

#### **语句覆盖**

使得程序中的每个可执行语句至少执行一次,**最弱的逻辑覆盖准则**

- 一个测试用例就可以（x = 4 , y = 5 , z = 5）

- ```java
  //只需取n=2和n=-1这两个测试用例，便可以满足语句覆盖
  public int fib(int n){
      if(n == 0)
          return 0;
      if(n == 1)
          return 1;
      if(n >= 2)
          return fib(n-1) + fib(n-2);
      else
          return -1;
  }
  ```

#### **分支/判定覆盖**

程序中的**每个判定**至少都获得一次“真”值和“假”值,依然**不能保证判断条件完全正确**,如`y>5错写成y<5`

- 测试用例1：x = 4 , y = 5 , z = 5 + 测试用例2：x = 2 , y = 5 , z = 5

#### **条件覆盖**

程序中每个判定包含的**每个条件的可能取值**（真/假）都至少满足一次

- ((a || b) && (c || d)) 条件为**四个**

- 测试用例1：x = 4 , y = 5 , z = 5 + 测试用例2：x = 2 , y = 5 , z = 15
- 条件覆盖并**不一定**比判定覆盖强，满足条件覆盖的测试用例不一定满足判定覆盖

![image-20221106155331031](/images/image-20221106155331031.png)

只需设计如下2个测试用例即可满足100%条件覆盖,**无需考虑是否真的执行了**

![预览大图](/images/1690230.png)

#### **判定/条件覆盖**

使得**判定中每个条件**的所有可能结果至少出现一次，**每个判定**本身所有可能结果也至少出现一次

![预览大图](/images/1686157.png)

#### **条件组合覆盖**

程序中**每个判定内**的所有可能的**条件**取值**组合**都至少出现一次，包含判定/条件覆盖

- ​	限于每个判定**内**
- （x>3,z<10   x<=3,z<10   x>3,z>=10   x>=3,z>=10）+（x==4,y>5  x==4,y,=5 x!=4,y>5 x!=4,y<=5）

> 现有8瓶一模一样的酒，其中一瓶有毒，需要人来测试出毒酒是哪一瓶。每次测试结果8小时后才会得出，而大家只有8个小时的时间。问最少需要几人才能测试出毒酒是哪一瓶
>
> 答：3人，2^3=8

#### **路径覆盖**

选取足够多测试数据，使程序的每条可能路径都至少执行一次

### 基本路径测试

- 计算McCabe环路复杂度N+1=6

<img src="/images/1565852.png" alt="预览大图" style="zoom: 33%;" />

- 确定独立路径

<img src="/images/1565890.png" alt="预览大图" style="zoom: 50%;" />

- 设计测试用例

### 循环测试

循环测试是一种白盒测试技术，它专注于测试循环结构的有效性。在结构化的程序中通常只有3种循环，即简单循环、串接循环和嵌套循环

![image-20221101201428744](/images/image-20221101201428744.png)



- 测试简单循环
  -  跳过循环
     只通过循环一次
     通过循环两次
     通过循环m次，其中m<n-1
     通过循环n-1,n,n+1次

```
Selenium是一个用于Web应用程序测试的工具
```

# 调试

调试（也称为纠错）作为成功测试的后果出现，即调试是在测试发现错误之后排除错误的过程

- **蛮干法/试探法**按照“让计算机自己寻找错误”的策略，这种方法印出内存的内容，激活对运行过程的跟踪，并在程序中到处都写上WRITE（输出）语句，效率低
- **回溯法**是一种相当常用的调试方法，当调试小程序时这种方法是有效的。具体做法：从发现症状的地方开始，人工沿程序的控制流往回追踪分析源程序代码，直到找出错误原因为止，适合小程序
- **原因排错法**
  - **对分查找法**的基本思路是，如果已经知道每个变量在程序内若干个关键点的正确值，则可以用赋值语句或输入语句在程序中点附近**“注入”这些变量的正确值**，然后运行程序并检查所得到的输出
  - **归纳法**是从个别现象推断出一般性结论的思维方法。使用这种方法调试程序时，首先把和错误有关的数据组织起来进行分析，以便发现可能的错误原因。然后**导出对错误原因的一个或多个假设，并利用已有的数据来证明或排除这些假设**
  - **演绎法**从一般原理或前提出发，经过排除和精化的过程推导出结论。采用这种方法调试程序时，首先**设想出所有可能的出错原因**，然后试图用测试来排除每一个假设的原因





https://blog.csdn.net/MarryLinDa/article/details/115031621

